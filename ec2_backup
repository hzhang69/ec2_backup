#!/bin/bash
###################################
# ec2 backup, a backup tool using AWS
#
# Authors:
# Eli Davis <edavis1@stevens.edu>
# Paul-Anthony Dudzinski <pdudzins@stevens.edu
# Nick Noga <nnoge@stevens.edu>
#
#(c) 2014 by The Authors
#
#
###################################

#Vars
#####################
f_debug=0
method=""
volume=""
volumeStatus=""
volumeSize=""
zone="us-east-1d"
configfile=""
ec2cert=""
ec2Home=""
ec2privatekey=""
ec2flags=""
sshflags=""

#Functions
#####################
usage() {
echo "ec2-backup [-h] [-m method] [-v volume-id] dir "
} 

#get the size and status of the volume
#the volume id is passed as the first and only argument
getVolumeStatus() {
volumeStatus=`aws --output text ec2 describe-volumes --volume-ids $1|awk '{print$6}'`
volumeSize=`aws --output text ec2 describe-volumes --volume-ids $1|awk '{print$4}'`

#if the volume does not come back in one of these two state it is unusable by out program
if [ "$volumeStatus" != "available" ] || [ "$volumeStatus" != "creating" ];then

	echo "The volume is in use, deleted, or there was an error creating it"
	exit 1
fi
}

#wait for the volume to become available
#there are no arguments for this function, it is dependent on global vars
volumeWait() {
	if [ $f_debug -eq 1 ]; then
		echo "inside the wait function"
	fi
        while [ "$volumeStatus" != "available" ]; do
                getVolumeStatus $volume
		sleep 1
		if [ $f_debug -eq 1 ]; then
                echo "Waiting for the volume to be available"
        	fi

        done
}

#This function should be passed the backup directory as the only argument
#the volume is set and checked for existence in the arg parser
#the global zone variable must be set, this can be done by the user environment or by the
#function that will create the instance 
getVolume() {

#Determine the size of the file and translate it into GB to run the command
bytesize=$(du -sb $1 2>/dev/null | cut -f1)
#this function produces a float and outputs 0 if > 1024 bytes
gbsize=$(python -c "from math import ceil; print ceil(ceil(ceil($bytesize/1024)/1024)/1024)")
#Convert gbsize to integer
gbsize=${gbsize/.*}
alloc=0

## Determine and allocate necessary volume size IF a volume was not provided
if [ -z $volume ]; then
        if [ $gbsize -eq 1 ] || [ $gbsize -eq 0 ]; then ## Minimum volume allocation is 1GB
                ## Allocate 2GB
                alloc=2
        elif [ $gbsize -lt 513 ] && [ $gbsize -gt 1 ]; then ## Maximum volume allocation is 1024GB
                ## Allocate 2*gbsize
                 let alloc=gbsize*2
        else
                echo "Directory is too large to be allocated into a single volume."
                exit 1
        fi
	if [ -z $alloc ] || [ $alloc -eq 0 ]; then
		echo "Invalid allocation size"
		exit 1
	fi

	volume=$(aws --output text ec2 create-volume --size $alloc --availability-zone $zone | awk '{print $6}')
	getVolumeStatus $volume
	#wait for the volume to be available busy wait....
	volumeWait 	
	echo $volume
else
##volume entered

	getVolumeStatus $volume
	#Only error here I can think of outside status and size is zone incompatibility
	if [ $gbsize -gt $volumeSize ]; then
		echo "The volume given is too small to backup the file"
                exit 1
	elif [ $gbsize -eq $volumeSize ] && [ $gbsize -ne 1 ]; then
		echo "The volume size and directory size are equal use a larger volume "
		exit 1
	fi

	volumeWait
	echo $volume
fi

}

getEnvironmentVars() {
ec2privatekey=$EC2_PRIVATE_KEY
ec2flags=${EC2_BACKUP_FLAGS_AWS}
sshflags=$EC2_BACKUP_FLAGS_SSH
verbose=$EC2_BACKUP_VERBOSE


#Parse the keypair from the variable on whitespace
f_keypair=0
f_secgroup=0
secgroup=""
keypair=""

#get the two arguments if they exist
args=($EC2_BACKUP_FLAGS_AWS)
for ((index=0; index <= ${#args[@]}; index++));
do
         if [ "${args[index]}" == "-security-groups" ]; then
                 secgroup=${args[index+1]}
         fi
         if [ "${args[index]}" == "-key-name" ]; then
                keypair=${args[index+1]}
         fi

done

#If either the keypair or the security group are null then exit 1
if [ -z  $keypair ] || [  -z $secgroup  ]; then
        echo "The keypair or the security group are empty please set them in EC2_BACKUP_FLAGS_AWS"
        exit 1
fi


#ask aws for the security groups and see if the input in the variable is in the list
for group in $( aws --output text  ec2 describe-security-groups |
		 awk -F"\t" '{if ($1 == "SECURITYGROUPS"){print $4}}')
do
	if [ "$group" = "$secgroup" ]; then
		f_secgroup=1
		break
	fi
done

# if the flag is equal 0 it was not in the list above, exit 1 b/c there is not a valid security group
if [ $f_secgroup -eq 0 ]; then
	echo "The security group that was supplied is not valid"
	exit 1
fi

#check the keypairs in the users setup and see if the keypair passed is in them
for key in $( aws --output text ec2 describe-key-pairs | awk -F"\t" '{print $3}')
do

	if [ "$key" = "$keypair" ]; then
		f_keypair=1
		break
	fi
done

# if the flag is equal 0 it was not in the list above, exit 1 b/c there is not a valid security group
if [ $f_keypair -eq 0 ]; then
        echo "The keypair that was supplied is not valid"
        exit 1
fi


}

#getInstance(){}


#Main
####################

while getopts "dhm:v:" o; do
    case "${o}" in
	d)
		f_debug=1
		;;
        h)
                usage
		exit 0
            ;;
        m)
		if [ "$OPTARG" = "dd" ] || [ "$OPTARG" = "rsync" ]; then
			method=$OPTARG
		else
			echo "Bad method argument choose rsync or dd"
			exit 1
		fi
            ;;
        v)
		if [[ $OPTARG =~ ^vol-.{8,20} ]]; then 
	                volume=$OPTARG
		else 
			echo "Volume id is not well formed"
			exit 1
		fi
		##Check to see if the volume is valid
		 volcheck=`aws ec2 describe-volumes --volume-ids $volume`
	 	if [[ "$volcheck" =~ ^A.client.error ]]; then
			echo "Error setting the volume, please check the volume"
			exit 1
		fi
           ;;

        *)
		usage
                exit 1;
            ;;
    esac
done

## Shift the args back the right spot
shift $(($OPTIND - 1))

if [ -z $1 ]; then
	echo "No Directory entered"
	exit 1
fi

if [ ! -d $1 ]; then
        echo "Argument is not a directory"
        exit 1
fi

##Maybe we should stat the file for error checking? Is there any case in which the above
##checks can be bypassed? More on this later
#stat $1

##Testing the functions
#getVolume $1
getEnvironmentVars

if [ $f_debug -eq 1 ]; then

	echo "Volume Status: " $volumeStatus
	echo "Volume Size: " $volumeSize
fi

exit 0


